#!/bin/bash

# DataOnline N8N Manager - Plugin Backup (FIXED)
# Phi√™n b·∫£n: 1.0.2 - Auto-detect Google Drive remote name

set -euo pipefail

# Source core modules
PLUGIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PLUGIN_PROJECT_ROOT="$(dirname "$(dirname "$PLUGIN_DIR")")"

# Source modules if not loaded
[[ -z "${LOGGER_LOADED:-}" ]] && source "$PLUGIN_PROJECT_ROOT/src/core/logger.sh"
[[ -z "${CONFIG_LOADED:-}" ]] && source "$PLUGIN_PROJECT_ROOT/src/core/config.sh"
[[ -z "${UTILS_LOADED:-}" ]] && source "$PLUGIN_PROJECT_ROOT/src/core/utils.sh"

# Constants
readonly BACKUP_BASE_DIR="/opt/n8n/backups"
readonly RCLONE_CONFIG="$HOME/.config/rclone/rclone.conf"
readonly CRON_JOB_NAME="n8n-backup"

# ===== HELPER FUNCTIONS FOR REMOTE DETECTION =====

# Get Google Drive remote name
get_gdrive_remote_name() {
    if [[ ! -f "$RCLONE_CONFIG" ]]; then
        return 1
    fi
    
    # Find Google Drive remote (type = drive)
    local remote_name=$(rclone listremotes | grep -E "^.*:$" | while read -r line; do
        local name="${line%:}"
        local type=$(rclone config show "$name" | grep "type = " | cut -d' ' -f3)
        if [[ "$type" == "drive" ]]; then
            echo "$name"
            break
        fi
    done)
    
    if [[ -n "$remote_name" ]]; then
        echo "$remote_name"
        return 0
    else
        return 1
    fi
}

# Save remote name to config
save_gdrive_remote_name() {
    local remote_name="$1"
    config_set "backup.gdrive_remote" "$remote_name"
}

# Get saved remote name from config
get_saved_gdrive_remote_name() {
    config_get "backup.gdrive_remote" ""
}

# ===== BACKUP FUNCTIONS =====

# T·∫°o backup n8n (FIXED - removed unnecessary sudo)
create_backup() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="n8n_backup_${timestamp}"
    local backup_dir="$BACKUP_BASE_DIR/$backup_name"

    log_info "üîÑ B·∫Øt ƒë·∫ßu backup n8n..." >&2

    # T·∫°o th∆∞ m·ª•c backup (only use sudo when needed)
    if [[ ! -d "$BACKUP_BASE_DIR" ]]; then
        if [[ -w "$(dirname "$BACKUP_BASE_DIR")" ]]; then
            mkdir -p "$BACKUP_BASE_DIR"
        else
            sudo mkdir -p "$BACKUP_BASE_DIR"
        fi
    fi
    
    if [[ -w "$BACKUP_BASE_DIR" ]]; then
        mkdir -p "$backup_dir"
    else
        sudo mkdir -p "$backup_dir"
    fi

    # 1. Backup PostgreSQL database (FIXED)
    log_info "üì¶ Backup database PostgreSQL..." >&2
    if docker exec n8n-postgres pg_dump -U n8n n8n >"$backup_dir/database.sql" 2>/dev/null; then
        log_success "‚úÖ Database backup th√†nh c√¥ng" >&2
    else
        log_error "‚ùå Database backup th·∫•t b·∫°i" >&2
        return 1
    fi

    # 2. Backup n8n data files (FIXED)
    log_info "üìÅ Backup n8n data files..." >&2
    local n8n_volume=$(docker volume inspect --format '{{ .Mountpoint }}' n8n_n8n_data 2>/dev/null)

    if [[ -n "$n8n_volume" ]]; then
        if [[ -w "$backup_dir" ]]; then
            tar -czf "$backup_dir/n8n_data.tar.gz" -C "$n8n_volume" . 2>/dev/null || {
                # Fallback with sudo if permission denied
                sudo tar -czf "$backup_dir/n8n_data.tar.gz" -C "$n8n_volume" . 2>/dev/null
            }
        else
            sudo tar -czf "$backup_dir/n8n_data.tar.gz" -C "$n8n_volume" . 2>/dev/null
        fi
        log_success "‚úÖ Data files backup th√†nh c√¥ng" >&2
    else
        log_error "‚ùå Kh√¥ng t√¨m th·∫•y n8n data volume" >&2
        return 1
    fi

    # 3. Backup docker-compose v√† config (FIXED)
    log_info "‚öôÔ∏è Backup c·∫•u h√¨nh..." >&2
    if [[ -f "/opt/n8n/docker-compose.yml" ]]; then
        cp /opt/n8n/docker-compose.yml "$backup_dir/" 2>/dev/null || \
        sudo cp /opt/n8n/docker-compose.yml "$backup_dir/"
    fi
    
    if [[ -f "/opt/n8n/.env" ]]; then
        cp /opt/n8n/.env "$backup_dir/" 2>/dev/null || \
        sudo cp /opt/n8n/.env "$backup_dir/" 2>/dev/null || true
    fi

    # 4. T·∫°o metadata
    cat >"$backup_dir/metadata.json" <<EOF
{
    "timestamp": "$(date -Iseconds)",
    "version": "$(docker exec n8n n8n --version 2>/dev/null || echo "unknown")",
    "type": "full",
    "size": "$(du -sh "$backup_dir" 2>/dev/null | cut -f1 || echo "unknown")"
}
EOF

    # 5. N√©n to√†n b·ªô backup (FIXED)
    log_info "üóúÔ∏è ƒêang n√©n backup..." >&2
    cd "$BACKUP_BASE_DIR"
    
    if [[ -w "$BACKUP_BASE_DIR" ]]; then
        tar -czf "${backup_name}.tar.gz" "$backup_name" 2>/dev/null && \
        rm -rf "$backup_name"
    else
        sudo tar -czf "${backup_name}.tar.gz" "$backup_name" 2>/dev/null && \
        sudo rm -rf "$backup_name"
    fi

    log_success "‚úÖ Backup ho√†n t·∫•t: ${backup_name}.tar.gz" >&2

    # Ch·ªâ echo ƒë∆∞·ªùng d·∫´n file, kh√¥ng c√≥ log messages
    echo "$BACKUP_BASE_DIR/${backup_name}.tar.gz"
}

# Upload backup l√™n Google Drive (FIXED - Auto-detect remote name)
upload_to_gdrive() {
    local backup_file="$1"
    
    if [[ ! -f "$RCLONE_CONFIG" ]]; then
        log_error "‚ùå Ch∆∞a c·∫•u h√¨nh Google Drive"
        return 1
    fi

    # Auto-detect remote name
    local remote_name
    if ! remote_name=$(get_gdrive_remote_name); then
        log_error "‚ùå Kh√¥ng t√¨m th·∫•y Google Drive remote"
        return 1
    fi

    log_info "‚òÅÔ∏è ƒêang upload l√™n Google Drive (remote: $remote_name)..."

    if rclone copy "$backup_file" "${remote_name}:n8n-backups/" --progress; then
        log_success "‚úÖ Upload th√†nh c√¥ng"
        return 0
    else
        log_error "‚ùå Upload th·∫•t b·∫°i"
        return 1
    fi
}

# Cleanup backup c≈© (FIXED - Auto-detect remote name)
cleanup_old_backups() {
    local retention_days=$(config_get "backup.retention_days" "30")

    log_info "üßπ D·ªçn d·∫πp backup c≈© h∆°n $retention_days ng√†y..."

    # Local cleanup
    find "$BACKUP_BASE_DIR" -name "n8n_backup_*.tar.gz" -mtime +$retention_days -delete 2>/dev/null || true

    # Google Drive cleanup (if configured)
    if [[ -f "$RCLONE_CONFIG" ]]; then
        local remote_name
        if remote_name=$(get_gdrive_remote_name); then
            rclone delete "${remote_name}:n8n-backups" --min-age "${retention_days}d" --include "n8n_backup_*.tar.gz" 2>/dev/null || true
            log_info "üßπ ƒê√£ d·ªçn d·∫πp Google Drive (remote: $remote_name)"
        fi
    fi
}

# ===== RESTORE FUNCTIONS =====

# Restore t·ª´ backup (FIXED)
restore_backup() {
    local backup_file="$1"

    log_info "üîÑ B·∫Øt ƒë·∫ßu restore t·ª´ backup..."

    # Ki·ªÉm tra file backup
    if [[ ! -f "$backup_file" ]]; then
        log_error "‚ùå File backup kh√¥ng t·ªìn t·∫°i: $backup_file"
        return 1
    fi

    # Extract backup
    local temp_dir="/tmp/n8n_restore_$(date +%s)"
    mkdir -p "$temp_dir"

    log_info "üì¶ ƒêang gi·∫£i n√©n backup..."
    tar -xzf "$backup_file" -C "$temp_dir"

    local backup_dir=$(find "$temp_dir" -name "n8n_backup_*" -type d | head -1)

    # Stop n8n
    log_info "‚èπÔ∏è D·ª´ng n8n services..."
    cd /opt/n8n
    docker compose down 2>/dev/null || sudo docker compose down

    # Restore database
    log_info "üóÑÔ∏è Restore database..."
    docker compose up -d postgres 2>/dev/null || sudo docker compose up -d postgres
    sleep 5

    docker exec -i n8n-postgres psql -U n8n -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;" 2>/dev/null
    docker exec -i n8n-postgres psql -U n8n n8n <"$backup_dir/database.sql"

    # Restore data files
    log_info "üìÅ Restore data files..."
    local n8n_volume=$(docker volume inspect --format '{{ .Mountpoint }}' n8n_n8n_data)
    
    # Remove old data and restore
    if [[ -w "$n8n_volume" ]]; then
        rm -rf "$n8n_volume"/*
        tar -xzf "$backup_dir/n8n_data.tar.gz" -C "$n8n_volume"
    else
        sudo rm -rf "$n8n_volume"/*
        sudo tar -xzf "$backup_dir/n8n_data.tar.gz" -C "$n8n_volume"
    fi

    # Start n8n
    log_info "‚ñ∂Ô∏è Kh·ªüi ƒë·ªông l·∫°i n8n..."
    docker compose up -d 2>/dev/null || sudo docker compose up -d

    # Cleanup
    rm -rf "$temp_dir"

    log_success "‚úÖ Restore ho√†n t·∫•t!"
}

# ===== CRON JOB MANAGEMENT =====

# C√†i ƒë·∫∑t cron job (FIXED)
setup_cron_job() {
    local frequency="$1" # daily, weekly, monthly
    local hour="${2:-2}" # Default 2 AM

    log_info "‚è∞ C√†i ƒë·∫∑t backup t·ª± ƒë·ªông..."

    # T·∫°o script wrapper
    local cron_script="/usr/local/bin/n8n-backup-cron.sh"

    # Create script content
    cat > /tmp/n8n-backup-cron.sh << EOF
#!/bin/bash
# N8N Backup Cron Script
export PATH="/usr/local/bin:/usr/bin:/bin"

# ƒê∆∞·ªùng d·∫´n t·ªõi th∆∞ m·ª•c backup v√† plugin
BACKUP_DIR="/opt/n8n/backups"
PLUGIN_DIR="$PLUGIN_DIR"
PROJECT_ROOT="$PLUGIN_PROJECT_ROOT"

# Source backup plugin tr·ª±c ti·∫øp
source "\$PROJECT_ROOT/src/core/logger.sh"
source "\$PROJECT_ROOT/src/core/config.sh"
source "\$PROJECT_ROOT/src/core/utils.sh"
source "\$PLUGIN_DIR/main.sh"

# T·∫°o backup
log_info "Starting automated backup..."
backup_file=\$(create_backup)

# Upload to Google Drive if configured
if [[ -f "\$HOME/.config/rclone/rclone.conf" ]] && [[ -n "\$backup_file" ]]; then
    upload_to_gdrive "\$backup_file"
fi

# Cleanup old backups
cleanup_old_backups
EOF

    # Install script with proper permissions
    if sudo cp /tmp/n8n-backup-cron.sh "$cron_script" 2>/dev/null && sudo chmod +x "$cron_script" 2>/dev/null; then
        rm -f /tmp/n8n-backup-cron.sh
        log_success "‚úÖ Cron script ƒë√£ ƒë∆∞·ª£c t·∫°o"
    else
        log_error "Kh√¥ng th·ªÉ t·∫°o cron script"
        return 1
    fi

    # Set cron schedule
    local cron_schedule
    case "$frequency" in
    "daily") cron_schedule="0 $hour * * *" ;;
    "weekly") cron_schedule="0 $hour * * 0" ;;
    "monthly") cron_schedule="0 $hour 1 * *" ;;
    *) cron_schedule="0 2 1 * *" ;; # Default monthly
    esac

    # Add to crontab
    (
        crontab -l 2>/dev/null | grep -v "$CRON_JOB_NAME"
        echo "$cron_schedule $cron_script # $CRON_JOB_NAME"
    ) | crontab -

    log_success "‚úÖ ƒê√£ c√†i ƒë·∫∑t backup $frequency l√∫c $hour:00"
    return 0
}

# ===== GOOGLE DRIVE SETUP (FIXED - Auto-detect remote name) =====

# C·∫•u h√¨nh Google Drive
setup_google_drive() {
    log_info "‚òÅÔ∏è C·∫§U H√åNH GOOGLE DRIVE BACKUP"
    echo ""

    # C√†i ƒë·∫∑t rclone n·∫øu ch∆∞a c√≥
    if ! command_exists rclone; then
        log_info "üì¶ C√†i ƒë·∫∑t rclone..."
        curl https://rclone.org/install.sh | sudo bash
    fi

    # Ki·ªÉm tra c·∫•u h√¨nh hi·ªán t·∫°i
    local existing_remote=""
    if [[ -f "$RCLONE_CONFIG" ]]; then
        existing_remote=$(get_gdrive_remote_name || echo "")
    fi

    if [[ -n "$existing_remote" ]]; then
        log_info "‚úÖ Google Drive ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh (remote: $existing_remote)"
        read -p "B·∫°n mu·ªën c·∫•u h√¨nh l·∫°i? [y/N]: " reconfigure
        if [[ ! "$reconfigure" =~ ^[Yy]$ ]]; then
            # Save existing remote name
            save_gdrive_remote_name "$existing_remote"
            return 0
        fi
    fi

    log_info "üîß B·∫Øt ƒë·∫ßu c·∫•u h√¨nh Google Drive v·ªõi rclone..."
    echo "üí° Rclone s·∫Ω h∆∞·ªõng d·∫´n b·∫°n t·ª´ng b∆∞·ªõc ƒë·ªÉ k·∫øt n·ªëi Google Drive"
    echo "üí° B·∫°n c√≥ th·ªÉ ƒë·∫∑t t√™n remote b·∫•t k·ª≥ (VD: gdrive, n8n, backup, ...)"
    echo ""

    # Ch·∫°y rclone config
    rclone config

    # Auto-detect remote name after configuration
    log_info "üîç ƒêang t·ª± ƒë·ªông nh·∫≠n di·ªán remote Google Drive..."
    
    local remote_name
    if remote_name=$(get_gdrive_remote_name); then
        log_success "‚úÖ ƒê√£ nh·∫≠n di·ªán remote: $remote_name"
        save_gdrive_remote_name "$remote_name"
    else
        log_error "‚ùå Kh√¥ng t√¨m th·∫•y remote Google Drive"
        return 1
    fi

    # Test connection
    log_info "üß™ Ki·ªÉm tra k·∫øt n·ªëi v·ªõi remote '$remote_name'..."
    if rclone lsd "${remote_name}:" >/dev/null 2>&1; then
        log_success "‚úÖ K·∫øt n·ªëi Google Drive th√†nh c√¥ng!"

        # T·∫°o th∆∞ m·ª•c backup
        log_info "üìÅ T·∫°o th∆∞ m·ª•c n8n-backups..."
        if rclone mkdir "${remote_name}:n8n-backups" 2>/dev/null || rclone lsd "${remote_name}:n8n-backups" >/dev/null 2>&1; then
            log_success "‚úÖ Th∆∞ m·ª•c n8n-backups ƒë√£ s·∫µn s√†ng tr√™n Google Drive"
        else
            log_error "‚ùå Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c backup"
            return 1
        fi
    else
        log_error "‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi Google Drive v·ªõi remote '$remote_name'"
        return 1
    fi
}

# ===== MENU FUNCTIONS =====

# Menu ch√≠nh backup
backup_menu_main() {
    while true; do
        echo ""
        log_info "üíæ QU·∫¢N L√ù BACKUP N8N"
        echo ""
        
        # Show current Google Drive status
        local remote_name=$(get_saved_gdrive_remote_name)
        if [[ -n "$remote_name" ]] && [[ -f "$RCLONE_CONFIG" ]]; then
            echo "‚òÅÔ∏è  Google Drive: ƒê√£ c·∫•u h√¨nh (remote: $remote_name)"
        else
            echo "‚òÅÔ∏è  Google Drive: Ch∆∞a c·∫•u h√¨nh"
        fi
        echo ""
        
        echo "1) üîÑ T·∫°o backup ngay"
        echo "2) üì• Restore t·ª´ backup"
        echo "3) ‚è∞ C·∫•u h√¨nh backup t·ª± ƒë·ªông"
        echo "4) ‚òÅÔ∏è  C·∫•u h√¨nh Google Drive"
        echo "5) üìã Xem danh s√°ch backup"
        echo "6) üßπ D·ªçn d·∫πp backup c≈©"
        echo "0) ‚¨ÖÔ∏è  Quay l·∫°i"
        echo ""

        read -p "Ch·ªçn [0-6]: " choice

        case "$choice" in
        1) backup_create_now ;;
        2) backup_restore_menu ;;
        3) backup_schedule_menu ;;
        4) setup_google_drive ;;
        5) backup_list ;;
        6) backup_cleanup_menu ;;
        0) return ;;
        *) log_error "L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá" ;;
        esac
    done
}

# C·∫£i thi·ªán function backup_create_now
backup_create_now() {
    log_info "üîÑ T·∫†O BACKUP NGAY"

    # Capture ch·ªâ ƒë∆∞·ªùng d·∫´n file, logs ƒë√£ ƒë∆∞·ª£c redirect sang stderr
    local backup_file
    backup_file=$(create_backup)

    if [[ -n "$backup_file" && -f "$backup_file" ]]; then
        log_success "Backup file: $(basename "$backup_file")"

        # H·ªèi upload Google Drive
        if [[ -f "$RCLONE_CONFIG" ]]; then
            local remote_name=$(get_gdrive_remote_name || echo "")
            if [[ -n "$remote_name" ]]; then
                read -p "Upload l√™n Google Drive (remote: $remote_name)? [Y/n]: " upload
                if [[ ! "$upload" =~ ^[Nn]$ ]]; then
                    upload_to_gdrive "$backup_file"
                fi
            else
                log_warn "Google Drive ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh ƒë√∫ng"
            fi
        fi
    else
        log_error "‚ùå Backup th·∫•t b·∫°i ho·∫∑c file kh√¥ng t·ªìn t·∫°i"
    fi
}

# Menu restore
backup_restore_menu() {
    log_info "üì• RESTORE T·ª™ BACKUP"
    echo ""

    # Li·ªát k√™ backup local
    echo "Backup local:"
    local backups=($(ls -t "$BACKUP_BASE_DIR"/n8n_backup_*.tar.gz 2>/dev/null))

    if [[ ${#backups[@]} -eq 0 ]]; then
        log_warn "Kh√¥ng c√≥ backup local"
    else
        for i in "${!backups[@]}"; do
            local backup="${backups[$i]}"
            local size=$(du -h "$backup" | cut -f1)
            local date=$(stat -c %y "$backup" | cut -d' ' -f1)
            echo "$((i + 1))) $(basename "$backup") - $size - $date"
        done
    fi

    echo ""
    read -p "Ch·ªçn backup ƒë·ªÉ restore [1-${#backups[@]}]: " choice

    if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -ge 1 ]] && [[ "$choice" -le ${#backups[@]} ]]; then
        local selected_backup="${backups[$((choice - 1))]}"

        log_warn "‚ö†Ô∏è  C·∫¢NH B√ÅO: Restore s·∫Ω ghi ƒë√® to√†n b·ªô data hi·ªán t·∫°i!"
        read -p "B·∫°n ch·∫Øc ch·∫Øn mu·ªën restore? [y/N]: " confirm

        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            restore_backup "$selected_backup"
        fi
    else
        log_error "L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá"
    fi
}

# Menu l·ªãch backup
backup_schedule_menu() {
    log_info "‚è∞ C·∫§U H√åNH BACKUP T·ª∞ ƒê·ªòNG"
    echo ""

    echo "T·∫ßn su·∫•t backup:"
    echo "1) H√†ng ng√†y"
    echo "2) H√†ng tu·∫ßn"
    echo "3) H√†ng th√°ng (m·∫∑c ƒë·ªãnh)"
    echo ""

    read -p "Ch·ªçn t·∫ßn su·∫•t [1-3]: " freq_choice

    local frequency="monthly"
    case "$freq_choice" in
    1) frequency="daily" ;;
    2) frequency="weekly" ;;
    3) frequency="monthly" ;;
    esac

    read -p "Gi·ªù backup (0-23, m·∫∑c ƒë·ªãnh 2): " hour
    hour=${hour:-2}

    if [[ ! "$hour" =~ ^[0-9]+$ ]] || [[ "$hour" -lt 0 ]] || [[ "$hour" -gt 23 ]]; then
        log_error "Gi·ªù kh√¥ng h·ª£p l·ªá"
        return
    fi

    if setup_cron_job "$frequency" "$hour"; then
        # L∆∞u config
        config_set "backup.schedule" "$frequency"
        config_set "backup.hour" "$hour"
        
        log_success "‚úÖ Backup t·ª± ƒë·ªông ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh: $frequency l√∫c $hour:00"
        echo ""
        read -p "Nh·∫•n Enter ƒë·ªÉ quay l·∫°i menu..."
    else
        log_error "‚ùå C·∫•u h√¨nh backup t·ª± ƒë·ªông th·∫•t b·∫°i"
        echo ""
        read -p "Nh·∫•n Enter ƒë·ªÉ quay l·∫°i menu..."
    fi
}

# Li·ªát k√™ backup (FIXED - Auto-detect remote name)
backup_list() {
    log_info "üìã DANH S√ÅCH BACKUP"
    echo ""

    echo "=== Backup Local ==="
    if [[ -d "$BACKUP_BASE_DIR" ]]; then
        ls -lh "$BACKUP_BASE_DIR"/n8n_backup_*.tar.gz 2>/dev/null || echo "Kh√¥ng c√≥ backup"
    fi

    echo ""

    if [[ -f "$RCLONE_CONFIG" ]]; then
        local remote_name=$(get_gdrive_remote_name || echo "")
        if [[ -n "$remote_name" ]]; then
            echo "=== Backup Google Drive (remote: $remote_name) ==="
            rclone ls "${remote_name}:n8n-backups/" 2>/dev/null || echo "Kh√¥ng th·ªÉ truy c·∫≠p Google Drive ho·∫∑c ch∆∞a c√≥ backup"
        else
            echo "=== Google Drive ==="
            echo "Ch∆∞a c·∫•u h√¨nh ho·∫∑c kh√¥ng t√¨m th·∫•y remote"
        fi
    fi
}

# Menu cleanup
backup_cleanup_menu() {
    log_info "üßπ D·ªåN D·∫∏P BACKUP C≈®"
    echo ""

    local retention_days=$(config_get "backup.retention_days" "30")
    echo "Retention hi·ªán t·∫°i: $retention_days ng√†y"
    echo ""

    read -p "Nh·∫≠p s·ªë ng√†y retention m·ªõi (Enter ƒë·ªÉ gi·ªØ nguy√™n): " new_retention

    if [[ -n "$new_retention" ]] && [[ "$new_retention" =~ ^[0-9]+$ ]]; then
        config_set "backup.retention_days" "$new_retention"
        retention_days=$new_retention
    fi

    cleanup_old_backups
}

# ===== INIT FUNCTION =====

# Kh·ªüi t·∫°o backup khi c√†i n8n
init_backup_on_install() {
    log_info "üîß Kh·ªüi t·∫°o backup t·ª± ƒë·ªông..."

    # T·∫°o th∆∞ m·ª•c backup
    if [[ -w "/opt/n8n" ]]; then
        mkdir -p "$BACKUP_BASE_DIR"
    else
        sudo mkdir -p "$BACKUP_BASE_DIR"
    fi

    # Setup cron job m·∫∑c ƒë·ªãnh (monthly)
    setup_cron_job "monthly" "2"

    # T·∫°o manager environment file
    cat > /tmp/manager-env.sh << EOF
# DataOnline N8N Manager Environment
export MANAGER_PATH="$PLUGIN_PROJECT_ROOT"
export BACKUP_DIR="$BACKUP_BASE_DIR"
EOF

    if [[ -w "/opt/n8n" ]]; then
        cp /tmp/manager-env.sh /opt/n8n/manager-env.sh
    else
        sudo cp /tmp/manager-env.sh /opt/n8n/manager-env.sh
    fi
    rm -f /tmp/manager-env.sh

    log_success "‚úÖ ƒê√£ c√†i ƒë·∫∑t backup t·ª± ƒë·ªông h√†ng th√°ng"
}

# Export functions
export -f backup_menu_main
export -f init_backup_on_install
export -f create_backup
export -f cleanup_old_backups